<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>不怎么好用的拍卖查询</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    /* 主题变量 */
    :root{
      --brand:#0078d7;
      --bg:#f6f7fb;
      --text:#222;
      --muted:#777;
      --border:#e6e6e6;
      --card:#fff;
      --hl-red:#d0021b;
      --hl-green:#0aaa55;
      --hl-orange:#ff9800;
    }

    html,body{
      height:100%;
    }

    /* 页面整体样式 */
    body {
      font-family: system-ui, -apple-system, "SF Pro Text", "Segoe UI", "Microsoft YaHei", Roboto, Arial, sans-serif;
      background:var(--bg);
      margin:0;
      color:var(--text);
      font-size:15px;
    }

    .page{
      max-width: 1600px;   /* 限制最大宽度，*/
      width: 100%;
      margin: 24px auto;
      padding: 0 16px;
      box-sizing: border-box;
    }

    .layout{
      display:flex;
      align-items:flex-start;
      gap:16px;
    }

    .left{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      gap:14px;
      min-width:0;
    }

    /* 顶部当前鸽子信息（吸顶） */
    .meta-wrap {
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .meta-box{
      background:#ffffffeb;
      border:1px solid #ddd;
      border-radius:12px;
      padding:14px 16px;
      font-size:15px;
      line-height:1.65;
      box-shadow:0 6px 16px rgba(0,0,0,.08);
      width:100%;
      box-sizing:border-box;
      backdrop-filter: blur(4px);
    }
    .meta-box .label {
      color:#666;
      display:inline-block;
      width:72px;
      vertical-align: top;
    }
    .meta-box .value {
      color:#111;
      font-weight:800;
    }
    .meta-box .value-block {
      color:#111;
      font-weight:600;
      white-space: pre-wrap;
      word-break: normal;
      display: inline;
    }

    /* 每个出价人的主卡片 */
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 2px 10px rgba(0,0,0,.20);
      position: relative;
      margin-top: 14px;
      box-sizing: border-box;
      display:flex;
      flex-direction:column;
      gap:12px;
      width:100%;
    }

    /* 卡片之间的明显分割线（从第二张卡开始） */
    .card + .card {
      margin-top: 32px; /* 卡片之间垂直间距更大一点 */
    }
    .card + .card::before {
      content: "";
      position: absolute;
      top: -18px;          /* 在线条位置稍微离上一张卡片一点 */
      left: -16px;         /* 把线延伸到卡片 padding 外，左右顶边 */
      right: -16px;
      border-top: 2px dashed #d0d0d0;
      opacity: 0.9;
      pointer-events: none;
    }

    /* 卡片状态高亮颜色 */
    .card.card-green{
      background: rgba(10,170,85,0.06);
      border-color: rgba(10,170,85,0.28);
      box-shadow: 0 0 8px rgba(10,170,85,0.15);
    }
    .card.card-red{
      background: rgba(208,2,27,0.06);
      border-color: rgba(208,2,27,0.28);
      box-shadow: 0 0 8px rgba(208,2,27,0.15);
    }
    .card.card-orange{
      background: rgba(246, 122, 4, 0.06);
      border-color: rgba(222, 144, 19, 0.28);
      box-shadow: 0 0 8px rgba(255, 150, 0, 0.15);
    }

    /* 上半部分布局：拍主信息 + 本场统计 + 全部场统计 */
    .card-top{
      display:grid;
      grid-template-columns: 2fr 1fr 1fr;
      gap:16px;
      align-items:flex-start;
    }
    .card-top-left,
    .card-top-mid,
    .card-top-right{
      display:flex;
      flex-direction:column;
      gap:8px;
      min-width:0;
    }

    /* 下半部分：历史记录 */
    .card-bottom{
      margin-top: 6px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .history-block{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width:0;
    }
    .history-header{
      font-weight:800;
      font-size:15px;
      color:#000;
      margin-bottom:4px;
    }

    /* 徽章：购买欲望高 / 鸽主 / 疑似鸽主 */
    .badge{
      font-size: 16px;
      margin-left: 4px;
      font-weight: 800;
    }
    .badge-green{ color: var(--hl-green); }
    .badge-red{   color: var(--hl-red); }
    .badge-orange{color: var(--hl-orange); }

    .center-muted { text-align:center; color:#999; }
    .err { text-align:center; color:#c0392b; margin-top:8px; }

    .hl-red{ color:var(--hl-red); font-weight:800; }
    .hl-green{ color:var(--hl-green); font-weight:800; }
    .subtle { color:var(--muted); font-size:15px; margin-top:4px; }

    /* 拍主信息 / 统计信息卡片：两列，不换行 */
    .stats-right,
    .info-card {
      white-space: nowrap;
      grid-template-columns: auto auto;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:10px;
      font-size:15px;
      background:rgba(0,0,0,.035);
      line-height:1.5;
      display:grid;
      column-gap:8px;
      row-gap:6px;
      box-sizing:border-box;
    }

    .info-card .label,
    .stats-right .label{
      color:#000;
      opacity:.7;
      font-weight:700;
    }
    .info-card .value,
    .stats-right .value{
      color:#000;
      font-weight:900;
      text-align:right;
    }

    .info-card .stat-item.full,
    .stats-right .stat-item.full {
      grid-column: 1 / -1;
    }

    .info-title {
      grid-column: 1 / -1;
      font-weight: 800;
      font-size: 15px;
      margin-bottom: 2px;
      color: #000;
    }

    /* 拍得记录的小卡片：固定宽度 + 竖排 */
    .history-item-card {
      background: rgba(0, 123, 255, 0.06);
      border: 1px solid rgba(0, 123, 255, 0.25);
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,.06);
      margin-bottom: 10px;

      display: block;          /* ❗竖排，每个占一行 */
      width: 520px;            /* ❗固定卡片宽度（你可以改成 480/600 等） */
      max-width: 100%;         /* 防止屏幕窄的时候超出 */
      white-space: nowrap;     /* 里边不换行，保持一条 */
    }

    .records-visible,
    .records-more {
      display: flex;
      flex-direction: column;     /* 垂直排列 */
      align-items: flex-start;    /* 从左边对齐 */
      gap: 6px;
    }



    .history-card {
      margin-top: 4px;
    }

    .group {
      padding: 0;
      border: none;
      background: transparent;
      box-shadow: none;
      margin-top: 0;
    }

    .history-row {
      grid-column: 1 / -1;
      font-size: 15px;
      line-height: 1.7;
      color: #333;
      white-space: normal;
    }

    .item {
      margin-left:0;
      white-space:normal;
      line-height:1.7;
    }

    /* 历史折叠：本场、全部各自控制 */
    .card .records-more { display: none; }

    .history-block.is-open .records-more { display:block; }
    .history-block.is-open .fold-tip { display:none; }

    .fold-tip {
      color: #999;
      font-size: 13px;
      text-align: center;
      margin-top: 4px;
    }

    .toggle-more {
      margin-top: 6px;
      padding: 4px 10px;
      font-size: 13px;
      color: var(--brand);
      background: rgba(255,255,255,0.9);
      border: 1px solid var(--border);
      border-radius: 6px;
      cursor: pointer;

      display: inline-block;   /* 与小卡片一致 */
      width: fit-content;       /* 关键：跟卡片一样宽度由内容决定 */
      white-space: nowrap;      /* 不换行 */
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);

      /* 对齐方式：左对齐，与卡片自然排版一致 */
    }

    .toggle-more:hover {
      background: rgba(255,255,255,1);
    }


    /* 拍主信息里的“出价时间”相对时间小字 */
    .bid-time .sub{
      font-size:13px;
      opacity:.65;
      font-weight:700;
      margin-left:4px;
    }

    /* 窄屏下改为单列 */
    @media (max-width: 860px){
      .card-top{
        grid-template-columns: 1fr;
      }
      .card-bottom{
        flex-direction:column;
      }
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="layout">
      <div class="left">
        <!-- 顶部当前鸽子信息 -->
        <div class="meta-wrap">
          <div class="meta-box" id="fixedMeta" aria-live="polite">
            <div><span class="label">成绩：</span><span class="value" id="m_name">-</span></div>
            <div><span class="label">环号：</span><span class="value" id="m_ring">-</span></div>
            <div><span class="label">鸽主：</span><span class="value" id="m_matcher">-</span></div>
            <hr>
            <div class="value-block" id="m_content"></div>
          </div>
        </div>

        <!-- 出价人卡片列表 -->
        <div id="list" role="list"></div>

        <!-- 错误提示 -->
        <div id="error" class="err" role="status" aria-live="polite"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // 相似度阈值：用于标记鸽主 / 疑似鸽主
  const SIM_THRESHOLD_SIMILAR = 0.50;
  const SIM_THRESHOLD_HIGH    = 0.80;

  // 名称高亮时忽略的词/字符
  const HIGHLIGHT_IGNORE_TERMS = ["鸽舍", "鸽苑"];
  const HIGHLIGHT_IGNORE_CHARS = "-—_·• ";
  const HIGHLIGHT_MIN_EFFECTIVE_LEN = 3;

  // SSE 地址
  const SSE_URL = new URL('/sse/pigeon', window.location.origin);

  // DOM 引用
  const list = document.getElementById("list");
  const errorBox = document.getElementById("error");
  const mName = document.getElementById("m_name");
  const mRing = document.getElementById("m_ring");
  const mMatcher = document.getElementById("m_matcher");
  const mContent = document.getElementById("m_content");

  const showError = msg => { errorBox.textContent = msg || ""; };
  const safe = v => (v===0 ? 0 : (v ?? "-"));

  // 数组按 key 分组
  const groupBy = (arr, keyFn) => {
    const m=new Map();
    (arr||[]).forEach(r=>{
      const k=keyFn(r);
      if(!m.has(k)) m.set(k,[]);
      m.get(k).push(r);
    });
    return m;
  };

  // 展示字段为字符串
  const displayQuote = v => (v==null ? "-" : (typeof v === "object"
    ? (()=>{ try{return JSON.stringify(v);}catch{return "-";} })()
    : String(v)));

  // 金额格式化
  function fmtMoney(v){
    const n = Number(v);
    return Number.isFinite(n) ? n.toLocaleString("zh-CN") : displayQuote(v);
  }

  // HTML 转义
  function escapeHtml(s){
    return String(s)
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#39;");
  }

  // 名称公共字符高亮
  function highlightCommonRuns(str, other, minLen = 2, cls = 'hl-red') {
    const a = Array.from(String(str ?? ''));
    const b = Array.from(String(other ?? ''));
    const n = a.length, m = b.length;

    const dp = Array(n + 1).fill(0).map(() => Array(m + 1).fill(0));
    const mark = Array(n).fill(false);

    // 动态规划找连续公共子串
    for (let i = 1; i <= n; i++) {
      for (let j = 1; j <= m; j++) {
        if (a[i - 1] === b[j - 1]) {
          dp[i][j] = dp[i - 1][j - 1] + 1;
          if (dp[i][j] >= minLen) {
            for (let k = 0; k < dp[i][j]; k++) {
              mark[i - 1 - k] = true;
            }
          }
        } else {
          dp[i][j] = 0;
        }
      }
    }

    // 根据有效长度（去掉鸽舍/鸽苑等）决定是否高亮
    const spans = [];
    let i = 0;
    while (i < n) {
      if (!mark[i]) { i++; continue; }
      let j = i;
      while (j < n && mark[j]) j++;

      const seg = a.slice(i, j).join('');

      let effective = seg;
      for (const term of HIGHLIGHT_IGNORE_TERMS) {
        if (!term) continue;
        effective = effective.split(term).join('');
      }
      effective = effective
        .split('')
        .filter(ch => !HIGHLIGHT_IGNORE_CHARS.includes(ch))
        .join('');

      if (effective.length >= HIGHLIGHT_MIN_EFFECTIVE_LEN) {
        spans.push([i, j]);
      }
      i = j;
    }

    // 重建带 span 的字符串
    let out = '';
    let pos = 0;
    for (const [s, e] of spans) {
      while (pos < s) {
        out += escapeHtml(a[pos]);
        pos++;
      }
      const seg = a.slice(s, e).join('');
      out += `<span class="${cls}">${escapeHtml(seg)}</span>`;
      pos = e;
    }
    while (pos < n) {
      out += escapeHtml(a[pos]);
      pos++;
    }

    return out || '-';
  }

  // 宽松数字解析
  function toNumberLoose(v){
    if (v == null) return NaN;
    const n = Number(v);
    if (Number.isFinite(n)) return n;
    const m = String(v).match(/-?\d+(\.\d+)?/);
    return m ? Number(m[0]) : NaN;
  }

  // 相似度归一化
  function normalizeScore(s){
    const n = toNumberLoose(s);
    if (!Number.isFinite(n)) return NaN;
    if (n > 1) return n / 100;
    if (n < 0) return 0;
    return n;
  }

  function pickItems(payload) {
    return Array.isArray(payload?.items) ? payload.items : Array.isArray(payload) ? payload : [];
  }

  function pickCurrent(payload) {
    if (payload && typeof payload.current === 'object' && payload.current) return payload.current;
    if (payload && payload.current_id && typeof payload.current_id === 'object') return payload.current_id;
    return null;
  }

  // 提取时间戳（毫秒）
  function pickCreateTimeMs(item){
    const raw = item?.create_time ?? item?.createTime ?? item?.ctime ?? item?.created_at ?? item?.createdAt;
    if (raw == null) return null;
    const n = Number(raw);
    if (!Number.isFinite(n)) return null;
    return n < 1e12 ? n * 1000 : n;
  }

  // 时间格式化
  const CN_FMT = new Intl.DateTimeFormat('zh-CN', {
    year:'numeric',month:'2-digit',day:'2-digit',
    hour:'2-digit',minute:'2-digit',second:'2-digit',
    hour12:false
  });
  function formatTime(ts){
    const ms = ts < 1e12 ? ts * 1000 : ts;
    return CN_FMT.format(new Date(ms)).replace(/\//g,'-');
  }

  // 相对时间文本
  function formatRelative(msTs){
    const now = Date.now();
    let diff = Math.max(0, Math.floor((now - msTs) / 1000));
    if (diff < 5) return '刚刚';
    if (diff < 60) return `${diff} 秒前`;
    const mins = Math.floor(diff / 60);
    if (mins < 60) return `${mins} 分钟前`;
    const hours = Math.floor(mins / 60);
    if (hours < 24) return `${hours} 小时前`;
    const days = Math.floor(hours / 24);
    if (days < 7) return `${days} 天前`;
    const weeks = Math.floor(days / 7);
    if (weeks < 5) return `${weeks} 周前`;
    const months = Math.floor(days / 30);
    if (months < 12) return `${months} 个月前`;
    const years = Math.floor(days / 365);
    return `${years} 年前`;
  }

  // 相对时间定时刷新（针对拍主信息里的出价时间）
  let rtTimer = null;
  function updateAllRelativeTimes(){
    document.querySelectorAll('.bid-time[data-ts]').forEach(el => {
      const ts = Number(el.getAttribute('data-ts'));
      if (!Number.isFinite(ts)) return;
      let sub = el.querySelector('.sub');
      if (!sub) {
        sub = document.createElement('span');
        sub.className = 'sub';
        el.appendChild(sub);
      }
      sub.textContent = formatRelative(ts);
      el.setAttribute('aria-label', `出价时间 ${formatTime(ts)}，${sub.textContent}`);
    });
  }
  function startRelativeTimer(){
    stopRelativeTimer();
    rtTimer = setInterval(updateAllRelativeTimes, 60_000);
  }
  function stopRelativeTimer(){
    if(rtTimer){ clearInterval(rtTimer); rtTimer=null; }
  }
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden) stopRelativeTimer(); else { updateAllRelativeTimes(); startRelativeTimer(); }
  });

  // 顶部当前鸽子信息渲染
  function renderCurrentMeta(current) {
    mName.textContent = current?.name ?? "-";
    mRing.textContent = safe(current?.footring ?? current?.foot_ring ?? current?.ring);
    const matcherName = current?.matchername ?? current?.matcher_name ?? current?.matcher;
    mMatcher.textContent = safe(matcherName);

    const contentVal = current?.content ?? current?.xlsx_content ?? current?.desc ?? current?.description;

    if (contentVal == null) {
      mContent.textContent = "-";
    } else if (typeof contentVal === "object") {
      mContent.textContent = JSON.stringify(contentVal);
    } else {
      const parts = String(contentVal).split(/[；;]+/).map(s => s.trim()).filter(Boolean);
      mContent.innerHTML = parts.length ? parts.map(escapeHtml).join("<br>") : escapeHtml(String(contentVal));
    }
  }

  // 构建历史记录面板（本场 / 全部）
  // 如果 rows 为空则返回 null（外层不显示这块）
  function buildHistoryPane(rows, titleText, currentMatcherName, card) {
    rows = rows || [];
    if (!rows.length) return null;

    const container = document.createElement('div');
    container.className = 'history-block';

    const header = document.createElement('div');
    header.className = 'history-header';
    header.textContent = titleText;
    container.appendChild(header);

    const groups = groupBy(rows, r => (r?.matcher_name ?? "-").toString().trim());
    const visibleWrap = document.createElement('div');
    visibleWrap.className = 'records-visible';
    const moreWrap = document.createElement('div');
    moreWrap.className = 'records-more';

    const MAX_GROUPS = 1;
    let idxGroup = 0;

    groups.forEach((arr, matcherNameRaw) => {
      const matcherName = matcherNameRaw || "-";

      const redMatcher = highlightCommonRuns(
        matcherName,
        currentMatcherName,
        2,
        'hl-red'
      );

      const quotes = arr
        .map(x => toNumberLoose(x?.quote) || 0)
        .filter(n => Number.isFinite(n) && n > 0)
        .sort((a, b) => b - a);

      const aggTotalFromServer = toNumberLoose(arr?.[0]?._agg_total);
      const totalPrice = Number.isFinite(aggTotalFromServer) && aggTotalFromServer > 0
        ? aggTotalFromServer
        : quotes.reduce((s, n) => s + n, 0);

      const highest = quotes[0] ?? 0;
      const second  = quotes[1] ?? 0;
      const aggCount = toNumberLoose(arr[0]?._agg_count ?? arr.length) || arr.length;

      // 组汇总卡片
      const cardBox = document.createElement('div');
      cardBox.className = 'info-card history-card group';

      cardBox.innerHTML = `
        <div class="stat-item full info-title">鸽主：${redMatcher}</div>
        <div class="stat-item">
          <span class="label">成交次数：</span>
          <span class="value">${displayQuote(aggCount)}</span>
        </div>
        <div class="stat-item">
          <span class="label">总价：</span>
          <span class="value">¥${displayQuote(totalPrice)}</span>
        </div>
        <div class="stat-item">
          <span class="label">最高：</span>
          <span class="value">¥${displayQuote(highest)}</span>
        </div>
        <div class="stat-item">
          <span class="label">次高：</span>
          <span class="value">¥${displayQuote(second)}</span>
        </div>
      `;

      // 每只鸽子的明细
      arr.forEach(row => {
        const subName = row.pigeon_name ?? row.pigeonName ?? row.name ?? "-";
        const subRing = row.foot_ring ?? row.footRing ?? "-";
        const subQuote = row.quote ?? "-";

        const rowDiv = document.createElement('div');
        rowDiv.className = 'history-row';
        rowDiv.textContent =
          `鸽名：${subName}  环号：${subRing}  价格：${displayQuote(subQuote)}`;

        cardBox.appendChild(rowDiv);
      });

      // 外层小卡片增强分组感
      const wrapper = document.createElement('div');
      wrapper.className = 'history-item-card';
      wrapper.appendChild(cardBox);

      const bucket = (idxGroup < MAX_GROUPS) ? visibleWrap : moreWrap;
      bucket.appendChild(wrapper);
      idxGroup++;
    });

    container.appendChild(visibleWrap);
    if (moreWrap.childElementCount > 0) {
      container.appendChild(moreWrap);

      const hiddenCount = groups.size - MAX_GROUPS;

      const ctl = document.createElement('button');
      ctl.className = 'toggle-more';
      ctl.type = 'button';
      ctl.textContent = `展开更多历史（${hiddenCount} 组，已折叠）`;
      ctl.addEventListener('click', () => {
        const opened = container.classList.toggle('is-open');
        if (opened) {
          ctl.textContent = `收起历史`;
        } else {
          ctl.textContent = `展开更多历史（${hiddenCount} 组，已折叠）`;
        }
      });
      container.appendChild(ctl);

      // const tip = document.createElement('div');
      // tip.className = 'fold-tip';
      // tip.textContent = `已折叠 ${hiddenCount} 组历史记录，可点击按钮展开`;
      // container.appendChild(tip);
    }

    return container;
  }

  // 主渲染函数
  function render(payload) {
    const current = pickCurrent(payload) || {};
    const currentMatcherName = (current?.matchername ?? current?.matcher_name ?? "").toString();

    renderCurrentMeta(current);

    list.innerHTML = "";
    const frag = document.createDocumentFragment();
    const items = pickItems(payload);

    if (!items.length) {
      const none = document.createElement('div');
      none.className = 'center-muted';
      none.textContent = '暂无数据';
      frag.appendChild(none);
      list.appendChild(frag);
      return;
    }

    // 每个 item 是一个出价人聚合
    items.forEach(item => {
      const userNickname = (item.user_nickname ?? "").toString();
      const userCode = item.user_code ?? "";
      const countNum = toNumberLoose(item.count);
      const countDisplay = Number.isFinite(countNum) ? countNum : safe(item.count);

      const outerSimVal = normalizeScore(item?._match_score ?? item?.match_score ?? item?.similarity);

      let innerBest = NaN;
      for (const arr of Object.values(item.results || {})) {
        if (!Array.isArray(arr)) continue;
        for (const row of arr) {
          const s = normalizeScore(row?._match_score ?? row?.match_score ?? row?.similarity);
          if (Number.isFinite(s) && (!Number.isFinite(innerBest) || s > innerBest)) {
            innerBest = s;
          }
        }
      }

      const simMax = Math.max(
        Number.isFinite(outerSimVal) ? outerSimVal : -Infinity,
        Number.isFinite(innerBest)   ? innerBest   : -Infinity
      );

      const card = document.createElement("div");
      card.className = "card";
      card.setAttribute('role','listitem');

      const cardTop = document.createElement('div');
      cardTop.className = 'card-top';
      const topLeft = document.createElement('div');
      topLeft.className = 'card-top-left';
      const topMid = document.createElement('div');
      topMid.className = 'card-top-mid';
      const topRight = document.createElement('div');
      topRight.className = 'card-top-right';

      // 状态判定
      const intentHigh = Number.isFinite(countNum) && countNum > 2;
      const flagRedHigh = Number.isFinite(simMax) && simMax >= SIM_THRESHOLD_HIGH;
      const flagRedMid  = !flagRedHigh && Number.isFinite(simMax) && simMax >= SIM_THRESHOLD_SIMILAR;

      if (flagRedHigh) {
        card.classList.add("card-red");
      }
      else if (flagRedMid) {
        card.classList.add("card-orange");
      }
      else if (intentHigh) {
        const depth = Math.min(countNum, 10);
        const hue = 120 - (Math.min(depth, 10) - 3) * 6;
        const light = 95 - Math.min((depth - 3) * 5, 25);
        const alpha = 0.40 + Math.min((depth - 3) * 0.05, 0.4);

        const bgColor = `hsla(${hue}, 70%, ${light}%, ${alpha})`;
        const borderColor = `hsla(${hue}, 70%, ${light - 20}%, ${alpha * 2})`;
        const shadowColor = `hsla(${hue}, 70%, ${light - 25}%, ${alpha * 1.5})`;

        card.style.background = bgColor;
        card.style.borderColor = borderColor;
        card.style.boxShadow = `0 0 10px ${shadowColor}`;
      }

      // 出价人名称高亮
      const greenNick = highlightCommonRuns(userNickname, currentMatcherName, 2, 'hl-red');

      // 计算出价时间（在拍主信息里用）
      const createTimeMs = pickCreateTimeMs(item);
      let timeRowHtml = '';
      if (createTimeMs) {
        timeRowHtml = `
          <div class="stat-item">
            <span class="label">出价时间：</span>
            <span class="value bid-time" data-ts="${createTimeMs}">
              ${formatTime(createTimeMs)} <span class="sub">${formatRelative(createTimeMs)}</span>
            </span>
          </div>
        `;
      }

      // 状态徽章 html
      let badgeHTML = '';
      if (intentHigh) {
        badgeHTML += '<span class="badge badge-green">（购买欲望高）</span>';
      }
      if (flagRedHigh) {
        badgeHTML += '<span class="badge badge-red">（鸽主）</span>';
      } else if (flagRedMid) {
        badgeHTML += '<span class="badge badge-orange">（疑似鸽主）</span>';
      }

      // 左侧拍主信息卡片：两行两列 + 出价时间
      const infoBidder = document.createElement('div');
      infoBidder.className = 'info-card';
      infoBidder.innerHTML = `
        <div class="stat-item full info-title">拍主信息</div>

        <div class="stat-item">
          <span class="label">出价人：</span>
          <span class="value">${greenNick}</span>
        </div>

        <div class="stat-item">
          <span class="label">出价ID：</span>
          <span class="value">
            ${escapeHtml(String(safe(userCode)).slice(-4))}${badgeHTML}
          </span>
        </div>

        <div class="stat-item">
          <span class="label">当前价：</span>
          <span class="value">¥${fmtMoney(item.quote)}</span>
        </div>

        <div class="stat-item">
          <span class="label">出价次数：</span>
          <span class="value">${escapeHtml(String(countDisplay))}</span>
        </div>

        ${timeRowHtml}
      `;
      topLeft.appendChild(infoBidder);

      // 中间：本场统计
      const bidCntRaw   = item.auction_bid_count;
      const totalPRaw   = item.auction_total_price;
      const highestRaw  = item.auction_highest_price;
      const secondRaw   = item.auction_second_highest_price;
      const isSet = v => v !== undefined && v !== null;

      const statsCurrent = document.createElement('div');
      statsCurrent.className = 'stats-right';
      statsCurrent.innerHTML = `
        <div class="stat-item full info-title">本场统计</div>
        <div class="stat-item">
          <span class="label">本场拍的次数：</span>
          <span class="value">${bidCntRaw ? String(bidCntRaw) : '-'}</span>
        </div>
        <div class="stat-item">
          <span class="label">本场拍得总价：</span>
          <span class="value">¥${totalPRaw ? fmtMoney(totalPRaw) : '-'}</span>
        </div>
        <div class="stat-item">
          <span class="label">最高价：</span>
          <span class="value">¥${isSet(highestRaw) ? fmtMoney(highestRaw) : '-'}</span>
        </div>
        <div class="stat-item">
          <span class="label">次高价：</span>
          <span class="value">¥${isSet(secondRaw) ? fmtMoney(secondRaw) : '-'}</span>
        </div>
      `;
      topMid.appendChild(statsCurrent);

      // 右侧：全部场统计
      const bidCntAll   = item.auction_bid_count_all;
      const totalPAll   = item.auction_total_price_all;
      const highestAll  = item.auction_highest_price_all;
      const secondAll   = item.auction_second_highest_price_all;

      const statsAll = document.createElement('div');
      statsAll.className = 'stats-right';
      statsAll.innerHTML = `
        <div class="stat-item full info-title">全部场统计</div>
        <div class="stat-item">
          <span class="label">全部场次数：</span>
          <span class="value">${bidCntAll ? String(bidCntAll) : '-'}</span>
        </div>
        <div class="stat-item">
          <span class="label">全部场总价：</span>
          <span class="value">¥${totalPAll ? fmtMoney(totalPAll) : '-'}</span>
        </div>
        <div class="stat-item">
          <span class="label">全部场最高：</span>
          <span class="value">¥${isSet(highestAll) ? fmtMoney(highestAll) : '-'}</span>
        </div>
        <div class="stat-item">
          <span class="label">全部场次高：</span>
          <span class="value">¥${isSet(secondAll) ? fmtMoney(secondAll) : '-'}</span>
        </div>
      `;
      topRight.appendChild(statsAll);

      cardTop.append(topLeft, topMid, topRight);

      // 下半部分：本场 / 全部历史记录（无内容则完全不显示这块）
      const cardBottom = document.createElement('div');
      cardBottom.className = 'card-bottom';

      let historyRows = Array.isArray((item.results || {})[userCode]) ? item.results[userCode] : null;
      if (!historyRows || !historyRows.length) {
        for (const v of Object.values(item.results || {})) {
          if (Array.isArray(v) && v.length) { historyRows = v; break; }
        }
      }
      historyRows = historyRows || [];

      const curAuctionId = item.auction_id ?? current.auction_id ?? null;

      const rowsCurrent = curAuctionId == null
        ? []
        : historyRows.filter(r => (r?.auction_id ?? null) === curAuctionId);

      const rowsAll = historyRows;

      // 本场有记录才生成面板
      if (rowsCurrent.length > 0) {
        const paneCurrent = buildHistoryPane(rowsCurrent, '本场拍得记录', currentMatcherName, card);
        if (paneCurrent) cardBottom.appendChild(paneCurrent);
      }

      // 全部有记录才生成面板
      if (rowsAll.length > 0) {
        const paneAll = buildHistoryPane(rowsAll, '全部拍得记录', currentMatcherName, card);
        if (paneAll) cardBottom.appendChild(paneAll);
      }

      // 如果本场和全部都没有，就不渲染 card-bottom
      if (cardBottom.childElementCount > 0) {
        card.appendChild(cardTop);
        card.appendChild(cardBottom);
      } else {
        card.appendChild(cardTop);
      }

      frag.appendChild(card);
    });

    list.appendChild(frag);
    updateAllRelativeTimes();
  }

  // SSE 连接
  let es = null;
  function connect(){
    es = new EventSource(SSE_URL);

    es.onopen = () => {
      showError("");
      startRelativeTimer();
    };

    es.onerror = () => {
      // 连接错误由 error 事件单独提示
    };

    // 出价数据事件
    es.addEventListener("bids", (ev) => {
      try {
        const data = JSON.parse(ev.data);
        render(data);
        showError("");
      } catch (err) {
        showError("数据解析错误：" + (err?.message || err));
      }
    });

    // 服务端错误事件
    es.addEventListener("error", (ev) => {
      try {
        const err = JSON.parse(ev.data);
        showError('服务端错误：' + (err?.message || err.data));
      } catch {
        showError('服务端错误：' + (ev.data || 'unknown'));
      }
    });
  }

  // 页面关闭时清理连接和定时器
  window.addEventListener('beforeunload', ()=>{
    try{ es?.close(); }catch{}
    stopRelativeTimer();
  });

  // 启动
  connect();
})();
</script>
</body>
</html>
